// VHDL Code Generator - Main Orchestration
// -------------------------------------------------------------
// Purpose: Main entry point and AST node dispatcher for VHDL code generation
// -------------------------------------------------------------

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "codegen_vhdl.h"
#include "codegen_vhdl_constants.h"
#include "codegen_vhdl_helpers.h"
#include "codegen_vhdl_types.h"
#include "codegen_vhdl_expressions.h"
#include "codegen_vhdl_statements.h"
#include "symbol_structs.h"
#include "utils.h"

// -------------------------------------------------------------
// Forward declarations
// -------------------------------------------------------------
static void generate_node(ASTNode *node, FILE *output_file);
static void generate_program(ASTNode *node, FILE *output_file);
static void generate_function_declaration(ASTNode *node, FILE *output_file);

// -------------------------------------------------------------
// Public entry point
// -------------------------------------------------------------
void generate_vhdl(ASTNode *root, FILE *output_file)
{
    generate_node(root, output_file);
}

// -------------------------------------------------------------
// Node dispatcher - routes AST nodes to appropriate generators
// -------------------------------------------------------------
static void generate_node(ASTNode *node, FILE *output_file)
{
    if (node == NULL)
    {
        return;
    }

    switch (node->type)
    {
        case NODE_PROGRAM:
            generate_program(node, output_file);
            break;
            
        case NODE_FUNCTION_DECL:
            generate_function_declaration(node, output_file);
            break;
            
        case NODE_STATEMENT:
            generate_statement_block(node, output_file, generate_node);
            break;
            
        case NODE_WHILE_STATEMENT:
            generate_while_loop(node, output_file, generate_node);
            break;
            
        case NODE_FOR_STATEMENT:
            generate_for_loop(node, output_file, generate_node);
            break;
            
        case NODE_IF_STATEMENT:
            generate_if_statement(node, output_file, generate_node);
            break;
            
        case NODE_BREAK_STATEMENT:
            generate_break_statement(node, output_file);
            break;
            
        case NODE_CONTINUE_STATEMENT:
            generate_continue_statement(node, output_file);
            break;
            
        case NODE_BINARY_EXPR:
            generate_binary_expression(node, output_file);
            break;
            
        case NODE_BINARY_OP:
            // Unary ops are stored in BINARY_OP nodes in the parser
            generate_unary_operation(node, output_file);
            break;
            
        case NODE_EXPRESSION:
            generate_expression(node, output_file);
            break;
            
        case NODE_FUNC_CALL:
            generate_function_call(node, output_file);
            break;
            
        default:
            // Intentionally ignored node types
            break;
    }
}

// -------------------------------------------------------------
// Program (top-level) code generation
// -------------------------------------------------------------
static void generate_program(ASTNode *node, FILE *output_file)
{
    int child_index = 0;

    // Emit VHDL header
    fprintf(output_file, "-- VHDL generated by compi\n\n");
    fprintf(output_file, "library IEEE;\n");
    fprintf(output_file, "use IEEE.STD_LOGIC_1164.ALL;\n");
    fprintf(output_file, "use IEEE.NUMERIC_STD.ALL;\n\n");

    // Emit struct type declarations
    emit_all_struct_declarations(output_file);

    // Generate code for all child nodes (functions)
    for (child_index = 0; child_index < node->num_children; ++child_index)
    {
        generate_node(node->children[child_index], output_file);
    }
}

// -------------------------------------------------------------
// Function declaration -> VHDL entity + architecture
// -------------------------------------------------------------
static void generate_function_declaration(ASTNode *node, FILE *output_file)
{
    const char *function_name = (node->value != NULL) ? node->value : DEFAULT_FUNCTION_NAME;
    ASTNode *parameters[MAX_PARAMETERS] = {NULL};
    int parameter_count = 0;
    int child_index = 0;

    // Entity declaration header
    fprintf(output_file, "-- Function: %s\n", function_name);
    fprintf(output_file, "entity %s is\n", function_name);
    fprintf(output_file, "  port (\n");
    fprintf(output_file, "    clk   : in  std_logic;\n");
    fprintf(output_file, "    reset : in  std_logic;\n");

    // Collect function parameters (variable declaration children)
    for (child_index = 0; child_index < node->num_children; ++child_index)
    {
        ASTNode *child_node = node->children[child_index];
        
        if (child_node->type == NODE_VAR_DECL)
        {
            parameters[parameter_count] = child_node;
            parameter_count++;
        }
    }

    // Emit input ports for each parameter
    for (child_index = 0; child_index < parameter_count; ++child_index)
    {
        ASTNode *parameter = parameters[child_index];
        int struct_index = find_struct_index(parameter->token.value);
        int is_struct_type = (struct_index >= 0);
        
        if (is_struct_type)
        {
            fprintf(output_file, "    %s : in %s_t;\n", 
                    parameter->value, parameter->token.value);
        }
        else
        {
            fprintf(output_file, "    %s : in %s;\n", 
                    parameter->value, ctype_to_vhdl(parameter->token.value));
        }
    }

    // Emit output port (result)
    if (node->token.value != NULL && strlen(node->token.value) > 0)
    {
        int return_struct_index = find_struct_index(node->token.value);
        int is_struct_return = (return_struct_index >= 0);
        
        if (is_struct_return)
        {
            fprintf(output_file, "    result : out %s_t\n", node->token.value);
        }
        else
        {
            fprintf(output_file, "    result : out %s\n", 
                    ctype_to_vhdl(node->token.value));
        }
    }
    else
    {
        fprintf(output_file, "    result : out std_logic_vector(%d downto 0)\n", 
                VHDL_BIT_WIDTH - 1);
    }
    
    fprintf(output_file, "  );\nend entity;\n\n");

    // Architecture declaration
    fprintf(output_file, "architecture behavioral of %s is\n", function_name);
    emit_function_local_signals(node, output_file);
    fprintf(output_file, "begin\n");
    fprintf(output_file, "  process(clk, reset)\n");
    fprintf(output_file, "  begin\n");
    fprintf(output_file, "    if reset = '1' then\n");
    fprintf(output_file, "      -- Reset logic (user-defined)\n");
    fprintf(output_file, "    elsif rising_edge(clk) then\n");

    // Generate function body statements
    for (child_index = 0; child_index < node->num_children; ++child_index)
    {
        ASTNode *child = node->children[child_index];
        
        if (child->type == NODE_STATEMENT)
        {
            generate_node(child, output_file);
        }
    }

    fprintf(output_file, "    end if;\n");
    fprintf(output_file, "  end process;\n");
    fprintf(output_file, "end architecture;\n\n");
}
